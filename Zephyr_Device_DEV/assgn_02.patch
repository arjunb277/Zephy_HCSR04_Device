diff -urN '--exclude=build' '--exclude=.git' '-x*.pyc' /home/arjun/Downloads/Zephyr_topatch/zephyr/drivers/sensor/CMakeLists.txt /home/arjun/Rtes/zephyrproject/zephyr/drivers/sensor/CMakeLists.txt
--- /home/arjun/Downloads/Zephyr_topatch/zephyr/drivers/sensor/CMakeLists.txt	2019-05-27 08:32:54.000000000 -0700
+++ /home/arjun/Rtes/zephyrproject/zephyr/drivers/sensor/CMakeLists.txt	2019-06-20 05:52:02.012850676 -0700
@@ -20,6 +20,7 @@
 add_subdirectory_ifdef(CONFIG_HDC1008		hdc1008)
 add_subdirectory_ifdef(CONFIG_HMC5883L		hmc5883l)
 add_subdirectory_ifdef(CONFIG_HP206C		hp206c)
+add_subdirectory_ifdef(CONFIG_HCSR04		hcsr04)
 add_subdirectory_ifdef(CONFIG_HTS221		hts221)
 add_subdirectory_ifdef(CONFIG_ISL29035		isl29035)
 add_subdirectory_ifdef(CONFIG_LIS2DH		lis2dh)
diff -urN '--exclude=build' '--exclude=.git' '-x*.pyc' /home/arjun/Downloads/Zephyr_topatch/zephyr/drivers/sensor/hcsr04/CMakeLists.txt /home/arjun/Rtes/zephyrproject/zephyr/drivers/sensor/hcsr04/CMakeLists.txt
--- /home/arjun/Downloads/Zephyr_topatch/zephyr/drivers/sensor/hcsr04/CMakeLists.txt	1969-12-31 17:00:00.000000000 -0700
+++ /home/arjun/Rtes/zephyrproject/zephyr/drivers/sensor/hcsr04/CMakeLists.txt	2019-06-20 05:50:34.330445466 -0700
@@ -0,0 +1,5 @@
+# SPDX-License-Identifier: Apache-2.0
+
+zephyr_library()
+
+zephyr_library_sources_ifdef(CONFIG_HCSR04 hcsr04.c)
diff -urN '--exclude=build' '--exclude=.git' '-x*.pyc' /home/arjun/Downloads/Zephyr_topatch/zephyr/drivers/sensor/hcsr04/hcsr04.c /home/arjun/Rtes/zephyrproject/zephyr/drivers/sensor/hcsr04/hcsr04.c
--- /home/arjun/Downloads/Zephyr_topatch/zephyr/drivers/sensor/hcsr04/hcsr04.c	1969-12-31 17:00:00.000000000 -0700
+++ /home/arjun/Rtes/zephyrproject/zephyr/drivers/sensor/hcsr04/hcsr04.c	2019-06-26 18:29:38.866125288 -0700
@@ -0,0 +1,328 @@
+#include <zephyr.h>
+#include <zephyr/types.h>
+#include <stdlib.h>
+#include <version.h>
+#include <device.h>
+#include <gpio.h>
+#include <kernel.h>
+#include <sensor.h>
+#include <pwm.h>
+#include <misc/util.h>
+#include <misc/printk.h>
+#include <misc/__assert.h>
+#include <pinmux.h>
+#include "../boards/x86/galileo/board.h"
+#include "../boards/x86/galileo/pinmux_galileo.h"
+#include "../drivers/gpio/gpio_dw_registers.h"
+#include "../drivers/gpio/gpio_dw.h"
+#include <shell/shell.h>
+
+#define EDGE_RISING	(GPIO_INT_EDGE | GPIO_INT_ACTIVE_HIGH)
+#define EDGE_FALLING (GPIO_INT_EDGE | GPIO_INT_ACTIVE_LOW)
+#define PULL_UP 	0	/* change this to enable pull-up/pull-down */
+
+static int hcsr04_init(struct device *dev); //driver init function
+
+/*Device data structure*/
+struct hcsr04_data {
+
+	struct device *gpio;
+	struct gpio_callback gpio_cb;
+	u8_t trig_io,echo_io;
+	u8_t trig_pin,echo_pin;
+	struct sensor_value result_buff;
+	u32_t start,stop;
+	u8_t status;
+	u32_t timeout;
+  struct k_sem my_sem;
+};
+
+/*Function to find zephyr pin number from shield number*/
+void io_to_zeph(struct device *dev,u8_t val1, u8_t val2)
+{
+   struct hcsr04_data *drv_data = dev->driver_data;
+   
+   if(val1 == 0){
+      
+      drv_data->trig_pin = 3;
+   }
+   else if(val1 == 1){
+
+   	  drv_data->trig_pin = 4;
+   }
+   else if(val1 == 2){
+
+   	  drv_data->trig_pin= 5;
+   }
+   else if(val1 == 3){
+
+   	  drv_data->trig_pin = 6;
+   }
+   else if(val1 == 10){
+
+   	  drv_data->trig_pin = 2;
+   }
+   else if(val1 == 12){
+
+   	  drv_data->trig_pin = 7;
+   }
+   else{
+
+   	printk("error: invalid selection for gpio trigger pin for device: %s", dev->config->name);
+    return;
+   }
+
+
+   if(val2 == 0){
+      
+      drv_data->echo_pin = 3;
+   }
+   else if(val2 == 1){
+
+   	  drv_data->echo_pin = 4;
+   }
+   else if(val2 == 2){
+
+   	  drv_data->echo_pin = 5;
+   }
+   else if(val2 == 3){
+
+   	  drv_data->echo_pin = 6;
+   }
+   else if(val2 == 10){
+
+   	  drv_data->echo_pin = 2;
+   }
+   else if(val2 == 12){
+
+   	  drv_data->echo_pin = 7;
+   }
+   else{
+
+   	printk("error: invalid selection for gpio echo pin for device: %s", dev->config->name);
+   	return;
+   }
+}
+
+/*Call back Function*/
+void measure_int(struct device *gpiob, struct gpio_callback *cb, u32_t pins)
+{
+  long long tmp = SYS_CLOCK_HW_CYCLES_TO_NS(k_cycle_get_32()); //taking time stamp
+  
+  /*using CONTAINER OF to get which device instance had an interrupt to get its pointer data*/
+  struct hcsr04_data *drv_data = CONTAINER_OF(cb, struct hcsr04_data, gpio_cb);
+  
+  int val; //to read pin value
+  int r; //return value for check
+
+  r = gpio_pin_read(drv_data->gpio,drv_data->echo_pin,&val); //reading pin value to decide which edge caused interrupt
+  if(r<0){
+  	printk("error in reading\n");
+  	return;
+  }
+
+  if(val == 1){
+   /*When Rising edge detected*/
+   drv_data->start = tmp; //start time stamp
+   drv_data->status = 1; //setting measurement status to on going 
+
+   r = gpio_pin_configure(drv_data->gpio,drv_data->echo_pin,PULL_UP | GPIO_DIR_IN | GPIO_INT | EDGE_FALLING); //set to detect falling 
+   if(r<0){
+   	 printk("error: gpio pin configure\n");
+  	 return;
+   }
+
+  }
+  else {
+   drv_data->stop = tmp; //stop time stamp
+
+   r = gpio_pin_configure(drv_data->gpio,drv_data->echo_pin,PULL_UP | GPIO_DIR_IN | GPIO_INT | EDGE_RISING); //set to detect rising 
+   if(r<0){
+   	 printk("error: gpio pin configure\n");
+  	 return;
+   }
+
+   	drv_data->result_buff.val1 = ((drv_data->stop) - (drv_data->start))/58000; //distance calculation 
+    k_sem_give(&(drv_data->my_sem)); //give sem when vadrv_data->status = 0; //measurement taken set value to zero or timed outlue is ready
+    drv_data->status = 0; //measurement taken set value to zero or timed out
+  } 
+     
+  return;
+ }
+
+ /*Set attribute of timeout from app*/
+ static int hcsr04_attr_set(struct device *dev,enum sensor_channel chan, enum sensor_attribute attr, const struct sensor_value *val )
+ {
+   struct hcsr04_data *drv_data = dev->driver_data; //getting pointer to device driver data 
+ 
+    drv_data->timeout = val->val1;
+ 
+   return 0;
+ }
+
+static int hcsr04_sample_fetch(struct device *dev, enum sensor_channel chan)
+{  
+  int r;
+  //printk("Sensor sample fetch called\n");
+  struct hcsr04_data *drv_data = dev->driver_data;
+
+  drv_data->result_buff.val1 = 0; //Clearing buffer when sample fetch is called.
+    
+  r = gpio_pin_write(drv_data->gpio,drv_data->trig_pin,1); //triggering 
+  if(r<0){
+  	printk("error: writing gpio\n");
+  	return 0;
+  }
+
+  k_sleep(10);
+
+  r = gpio_pin_write(drv_data->gpio,drv_data->trig_pin,0);
+  if(r<0){
+  	printk("error: writing gpio\n");
+  	return 0;
+   } 
+  
+  return 0;
+}
+
+static int hcsr04_channel_get(struct device *dev, enum sensor_channel chan, struct sensor_value *val)
+{
+  k_sleep(10); //delayed start to channel get
+
+  struct hcsr04_data *drv_data = dev->driver_data;
+
+  if(drv_data->result_buff.val1 != 0) //if buffer is empty
+  {
+    printk("Value available.\n");
+    val->val1 = drv_data->result_buff.val1; //getting value 
+    drv_data->result_buff.val1 = 0; //clearing buffer 
+  }
+  else
+  { 
+    if(drv_data->status != 0) //if measurement is ongoing 
+    { 
+       printk("Condition: buffer = empty,status = 1\n");
+       if(k_sem_take(&(drv_data->my_sem), K_MSEC(drv_data->timeout)/1000) != 0) //wait for value 
+      {
+        drv_data->result_buff.val1 = 0; 
+        hcsr04_init(dev); //re-initializing just in case
+        return -1;//time out
+      }
+     else
+      {
+        printk("Value available\n"); // value available now 
+        val->val1 = drv_data->result_buff.val1;
+        drv_data->result_buff.val1 = 0;   
+      }
+    }
+     else
+    {
+        hcsr04_sample_fetch(dev,SENSOR_CHAN_ALL); //triger again if status is zero.
+        printk("Condition: buffer = empty,status = 0\n");
+        if(k_sem_take(&(drv_data->my_sem), K_MSEC(drv_data->timeout)/1000) != 0) //wait for value
+      {
+        drv_data->result_buff.val1 = 0;
+        hcsr04_init(dev); //re-initializing again just in case 
+        return -1;  //time out
+      }
+     else
+      {
+        printk("Value available\n"); 
+        val->val1 = drv_data->result_buff.val1;
+        drv_data->result_buff.val1 = 0;   
+      }
+    }  
+  }
+return 0;
+}
+
+/*Driver API struct*/
+static const struct sensor_driver_api hcsr04_driver_api = {
+   .sample_fetch = hcsr04_sample_fetch,
+   .channel_get = hcsr04_channel_get,
+   .attr_set = hcsr04_attr_set,
+};
+
+/*Driver init function*/
+static int hcsr04_init(struct device *dev)
+{
+  int r;
+  struct device *pinmux;
+
+  struct hcsr04_data *drv_data = dev->driver_data;
+  
+  pinmux = device_get_binding(CONFIG_PINMUX_NAME); /*Pinmux device*/
+  if(pinmux==NULL){
+  	printk("error: could not bind pinmux");
+  	return 0;
+  }
+
+  struct galileo_data *data = pinmux->driver_data;
+
+  drv_data->gpio = data->gpio_dw; /*Gpio Device initialization.*/
+  if(drv_data->gpio == NULL){
+  	printk("error: gpio device\n");
+  	return 0;
+  }
+
+  /*Setting trigger and echo pin values*/
+  if((strcmp(dev->config->name,"HCSR04_0")) == 0){
+      drv_data->trig_io = CONFIG_HCSR0_TRIG_IO;
+      drv_data->echo_io = CONFIG_HCSR0_ECHO_IO;	
+      drv_data->timeout = CONFIG_HCSR0_TIMEOUT;    
+      drv_data->status = 0; 
+  }
+  else{
+      drv_data->trig_io = CONFIG_HCSR1_TRIG_IO;
+      drv_data->echo_io = CONFIG_HCSR1_ECHO_IO;
+      drv_data->timeout = CONFIG_HCSR1_TIMEOUT;
+      drv_data->status = 0;
+  }
+   
+  io_to_zeph(dev,drv_data->trig_io,drv_data->echo_io); // io to zephyr pin
+
+  r = pinmux_pin_set(pinmux,drv_data->trig_io,PINMUX_FUNC_A); //trigger pin as output 
+  if(r<0){
+  	printk("error: pin for trigger.\n");
+  	return 0;
+  }
+
+  r = pinmux_pin_set(pinmux,drv_data->echo_io,PINMUX_FUNC_B); //echo pin as input 
+  if(r<0){
+  	printk("error: pin for echo.\n");
+  	return 0;
+  }
+
+  r = gpio_pin_configure(drv_data->gpio,drv_data->echo_pin,PULL_UP | GPIO_DIR_IN | GPIO_INT | EDGE_RISING); //to detect rising edge 
+  if(r<0){
+  	printk("error: gpio pin configure\n");
+  	return 0;
+  }
+
+  /*Initializong interrupts*/
+  gpio_init_callback(&(drv_data->gpio_cb), measure_int, BIT(drv_data->echo_pin)); 
+
+   r = gpio_add_callback(drv_data->gpio,&(drv_data->gpio_cb));   
+  if(r<0){
+      printk("error adding callback\n");
+      return 0;
+  }
+
+  r = gpio_pin_enable_callback(drv_data->gpio,drv_data->echo_pin);
+  if(r<0) {
+      printk("error enabling callback\n");
+      return 0;
+  }
+
+  
+  k_sem_init(&drv_data->my_sem,0,1); //initializing semaphore for timeout.
+  
+  return 0;
+}
+
+/*Creating two instances of devices*/
+struct hcsr04_data hcsr04_data_0, hcsr04_data_1;
+
+DEVICE_AND_API_INIT(HCSR0,"HCSR04_0",hcsr04_init,&hcsr04_data_0,NULL,POST_KERNEL,CONFIG_SENSOR_INIT_PRIORITY,&hcsr04_driver_api);
+DEVICE_AND_API_INIT(HCSR1,"HCSR04_1",hcsr04_init,&hcsr04_data_1,NULL,POST_KERNEL,CONFIG_SENSOR_INIT_PRIORITY,&hcsr04_driver_api);
+
diff -urN '--exclude=build' '--exclude=.git' '-x*.pyc' /home/arjun/Downloads/Zephyr_topatch/zephyr/drivers/sensor/hcsr04/Kconfig /home/arjun/Rtes/zephyrproject/zephyr/drivers/sensor/hcsr04/Kconfig
--- /home/arjun/Downloads/Zephyr_topatch/zephyr/drivers/sensor/hcsr04/Kconfig	1969-12-31 17:00:00.000000000 -0700
+++ /home/arjun/Rtes/zephyrproject/zephyr/drivers/sensor/hcsr04/Kconfig	2019-06-24 23:01:16.875721207 -0700
@@ -0,0 +1,67 @@
+# Kconfig - HC-SR04 ultrasonic distance sensor configuration options
+
+#
+# Copyright (c) 2016 Intel Corporation
+#
+# SPDX-License-Identifier: Apache-2.0
+#
+
+menuconfig HCSR04
+	bool "HCSR04 Ultrasonic Distance Sensor"
+	depends on GPIO 
+	help
+	  Enable driver for HCSR04 ultrasonic distance sensor.
+
+if HCSR04      
+
+config HCSR04_0
+        string "Driver's name"
+        default "HCSR0"
+        depends on HCSR04
+        help
+          Device name to identify HCSR04 sensor.
+
+config HCSR04_1
+        string "Driver's name"
+        default "HCSR1"
+        depends on HCSR04
+        help
+          Device name to identify HCSR04 sensor.
+
+config HCSR0_TRIG_IO
+        int  "Shield pin for HCSR0 trigger"
+        default 2
+        help
+          Trigger shield pin number for HCSR04_0 sensor.
+
+config HCSR0_ECHO_IO
+        int  "Shield pin for HCSR0 echo"
+        default 3
+        help
+          Echo shield pin number for HCSR04_0 sensor.
+
+config HCSR0_TIMEOUT
+       int "Sensor HCSR04 0 timeout value in microsec."
+       default 1000000
+       help 
+           Sensor timeout value for HCSR04_0 sensor in microsec.
+
+config HCSR1_TRIG_IO
+        int  "Shield pin for HCSR1 trigger in microsec"
+        default 10
+        help
+          Trigger shield pin number for HCSR04_1 sensor in microsec.
+
+config HCSR1_ECHO_IO
+        int  "Shield pin for HCSR1 echo"
+        default 12
+        help
+          Echo shield pin number for HCSR04_0 sensor in microsec.
+
+config HCSR1_TIMEOUT
+       int "Sensor HCSR04 1 timeout value."
+       default 2000000
+       help 
+           Sensor timeout value for HCSR04_1 sensor in microsec.
+
+endif # HCSR04
\ No newline at end of file
diff -urN '--exclude=build' '--exclude=.git' '-x*.pyc' /home/arjun/Downloads/Zephyr_topatch/zephyr/drivers/sensor/Kconfig /home/arjun/Rtes/zephyrproject/zephyr/drivers/sensor/Kconfig
--- /home/arjun/Downloads/Zephyr_topatch/zephyr/drivers/sensor/Kconfig	2019-05-27 08:32:54.000000000 -0700
+++ /home/arjun/Rtes/zephyrproject/zephyr/drivers/sensor/Kconfig	2019-06-20 05:51:40.174117809 -0700
@@ -65,6 +65,8 @@
 
 source "drivers/sensor/hp206c/Kconfig"
 
+source "drivers/sensor/hcsr04/Kconfig"
+
 source "drivers/sensor/hts221/Kconfig"
 
 source "drivers/sensor/isl29035/Kconfig"
diff -urN '--exclude=build' '--exclude=.git' '-x*.pyc' /home/arjun/Downloads/Zephyr_topatch/zephyr/samples/gpio_led/CMakeFiles/cmake.check_cache /home/arjun/Rtes/zephyrproject/zephyr/samples/gpio_led/CMakeFiles/cmake.check_cache
--- /home/arjun/Downloads/Zephyr_topatch/zephyr/samples/gpio_led/CMakeFiles/cmake.check_cache	1969-12-31 17:00:00.000000000 -0700
+++ /home/arjun/Rtes/zephyrproject/zephyr/samples/gpio_led/CMakeFiles/cmake.check_cache	2019-05-26 17:14:49.180923000 -0700
@@ -0,0 +1 @@
+# This file is generated by cmake for dependency checking of the CMakeCache.txt file
diff -urN '--exclude=build' '--exclude=.git' '-x*.pyc' /home/arjun/Downloads/Zephyr_topatch/zephyr/samples/gpio_led/CMakeLists.txt /home/arjun/Rtes/zephyrproject/zephyr/samples/gpio_led/CMakeLists.txt
--- /home/arjun/Downloads/Zephyr_topatch/zephyr/samples/gpio_led/CMakeLists.txt	1969-12-31 17:00:00.000000000 -0700
+++ /home/arjun/Rtes/zephyrproject/zephyr/samples/gpio_led/CMakeLists.txt	2019-05-24 11:34:58.000000000 -0700
@@ -0,0 +1,9 @@
+
+# SPDX-License-Identifier: Apache-2.0
+
+cmake_minimum_required(VERSION 3.13.1)
+include($ENV{ZEPHYR_BASE}/cmake/app/boilerplate.cmake NO_POLICY_SCOPE)
+project(gpio_led)
+
+FILE(GLOB app_sources src/*.c)
+target_sources(app PRIVATE ${app_sources})
diff -urN '--exclude=build' '--exclude=.git' '-x*.pyc' /home/arjun/Downloads/Zephyr_topatch/zephyr/samples/gpio_led/prj.conf /home/arjun/Rtes/zephyrproject/zephyr/samples/gpio_led/prj.conf
--- /home/arjun/Downloads/Zephyr_topatch/zephyr/samples/gpio_led/prj.conf	1969-12-31 17:00:00.000000000 -0700
+++ /home/arjun/Rtes/zephyrproject/zephyr/samples/gpio_led/prj.conf	2019-05-22 21:22:02.000000000 -0700
@@ -0,0 +1,7 @@
+# nothing here
+CONFIG_PRINTK=y
+CONFIG_SHELL=y
+#CONFIG_KERNEL_SHELL=y
+CONFIG_OBJECT_TRACING=y
+CONFIG_THREAD_MONITOR=y
+CONFIG_INIT_STACKS=y
diff -urN '--exclude=build' '--exclude=.git' '-x*.pyc' /home/arjun/Downloads/Zephyr_topatch/zephyr/samples/gpio_led/README.rst /home/arjun/Rtes/zephyrproject/zephyr/samples/gpio_led/README.rst
--- /home/arjun/Downloads/Zephyr_topatch/zephyr/samples/gpio_led/README.rst	1969-12-31 17:00:00.000000000 -0700
+++ /home/arjun/Rtes/zephyrproject/zephyr/samples/gpio_led/README.rst	2019-05-24 11:34:54.000000000 -0700
@@ -0,0 +1,26 @@
+.. _gpio_led:
+
+LED blinking with GPIO signals
+###########
+
+Overview
+********
+A simple example that can be used with galileo board to control a RGB led
+
+Building and Running
+********************
+
+This project outputs 3 gpio signals to light up a RGB led.  It can be built and executed
+on QEMU as follows:
+
+.. zephyr-app-commands::
+   :zephyr-app: samples/gpio_led
+   :board: galileo   
+   :conf: prj.conf
+   :goals: run
+   :compact:
+
+Sample Output
+=============
+
+.. light up a RGB led connected to IO1, IO2, and IO10
diff -urN '--exclude=build' '--exclude=.git' '-x*.pyc' /home/arjun/Downloads/Zephyr_topatch/zephyr/samples/gpio_led/sample.yaml /home/arjun/Rtes/zephyrproject/zephyr/samples/gpio_led/sample.yaml
--- /home/arjun/Downloads/Zephyr_topatch/zephyr/samples/gpio_led/sample.yaml	1969-12-31 17:00:00.000000000 -0700
+++ /home/arjun/Rtes/zephyrproject/zephyr/samples/gpio_led/sample.yaml	2019-05-24 11:36:06.000000000 -0700
@@ -0,0 +1,15 @@
+sample:
+  description: gpio_led sample, a simple Zephyr
+    application
+  name: gpio_led
+  platforms: all
+tests:
+  - test:
+      build_only: true
+      filter: CONFIG_UART_CONSOLE and CONFIG_SERIAL_SUPPORT_INTERRUPT
+	  tags: samples tests
+  - singlethread:
+      build_only: true
+      extra_args: CONF_FILE=prj.conf
+      filter: not CONFIG_BT and not CONFIG_GPIO_SCH
+      tags: samples tests
diff -urN '--exclude=build' '--exclude=.git' '-x*.pyc' /home/arjun/Downloads/Zephyr_topatch/zephyr/samples/gpio_led/src/main.c /home/arjun/Rtes/zephyrproject/zephyr/samples/gpio_led/src/main.c
--- /home/arjun/Downloads/Zephyr_topatch/zephyr/samples/gpio_led/src/main.c	1969-12-31 17:00:00.000000000 -0700
+++ /home/arjun/Rtes/zephyrproject/zephyr/samples/gpio_led/src/main.c	2019-05-24 11:42:38.000000000 -0700
@@ -0,0 +1,165 @@
+/*
+ * Copyright (c) 2016 Open-RnD Sp. z o.o.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#include <zephyr.h>
+//#include <board.h>
+#include <version.h>
+#include <device.h>
+#include <gpio.h>
+#include <pwm.h>
+#include <misc/util.h>
+#include <misc/printk.h>
+#include <pinmux.h>
+#include "../boards/x86/galileo/board.h"
+#include "../boards/x86/galileo/pinmux_galileo.h"
+#include "../drivers/gpio/gpio_dw_registers.h"
+#include "../drivers/gpio/gpio_dw.h"
+#include <shell/shell.h>
+
+#define EDGE_FALLING    (GPIO_INT_EDGE | GPIO_INT_ACTIVE_LOW)
+#define EDGE_RISING	(GPIO_INT_EDGE | GPIO_INT_ACTIVE_HIGH)
+#define PULL_UP 	0	/* change this to enable pull-up/pull-down */
+#define SLEEP_TIME	1000	/* Sleep time */
+
+// from sample/subsys/shell/shell_module for demo
+
+static int cmd_demo_ping(const struct shell *shell, size_t argc, char **argv)
+{
+	ARG_UNUSED(argc);
+	ARG_UNUSED(argv);
+
+	shell_print(shell, "pong");
+
+	return 0;
+}
+
+static int cmd_demo_params(const struct shell *shell, size_t argc, char **argv)
+{
+	shell_print(shell, "argc = %d", argc);
+	for (size_t cnt = 0; cnt < argc; cnt++) {
+		shell_print(shell, "  argv[%d] = %s", cnt, argv[cnt]);
+	}
+
+	return 0;
+}
+
+static int cmd_version(const struct shell *shell, size_t argc, char **argv)
+{
+	ARG_UNUSED(argc);
+	ARG_UNUSED(argv);
+
+	shell_print(shell, "Zephyr version %s", KERNEL_VERSION_STRING);
+
+	return 0;
+}
+
+SHELL_STATIC_SUBCMD_SET_CREATE(sub_demo,
+	SHELL_CMD(params, NULL, "Print params command.", cmd_demo_params),
+	SHELL_CMD(ping, NULL, "Ping command.", cmd_demo_ping),
+	SHELL_CMD(version, NULL, "Version command.", cmd_version),
+	SHELL_SUBCMD_SET_END /* Array terminated. */
+);
+SHELL_CMD_REGISTER(demo, &sub_demo, "Demo commands", NULL);
+
+
+static struct device *pinmux;  
+
+void main(void)
+{
+	
+	struct device *gpiob, *pwm0;
+	int ret, flag, iter, total_iter;
+
+	u32_t gpio_d;
+	
+	printk("Start running gpio, interrupt, and pwm testing program \n");
+	
+	pinmux=device_get_binding(CONFIG_PINMUX_NAME);
+
+	struct galileo_data *dev = pinmux->driver_data;
+	
+    	gpiob=dev->gpio_dw; 	//retrieving gpio_dw driver struct from pinmux driver
+				// Alternatively, gpiob = device_get_binding(PORT);
+	if (!gpiob) {
+		printk("error\n");
+		return;
+	}
+
+	pwm0 = dev->pwm0;
+	if (!pwm0) {
+		printk("error\n");
+		return;
+	}	
+
+	ret=pinmux_pin_set(pinmux,10,PINMUX_FUNC_A); 	//IO 10
+	if(ret<0)
+		printk("error setting pin for IO10\n");
+	
+	ret=pinmux_pin_set(pinmux,1,PINMUX_FUNC_A); 	//IO1
+	if(ret<0)
+		printk("error setting pin for IO1\n");
+	
+	ret=pinmux_pin_set(pinmux,2,PINMUX_FUNC_A); 	//IO2
+	if(ret<0)
+		printk("error setting pin for IO2\n");
+	
+	ret=pinmux_pin_set(pinmux,3,PINMUX_FUNC_B); 	//IO3 for input interrupt
+	if(ret<0)
+		printk("error setting pin for IO3\n");
+
+	ret=pinmux_pin_set(pinmux,9,PINMUX_FUNC_C); 	//IO9 for pwm 3
+	if(ret<0)
+		printk("error setting pin for IO9\n");
+
+	ret=pinmux_pin_set(pinmux,5,PINMUX_FUNC_C); 	//IO5 for pwm 7
+	if(ret<0)
+		printk("error setting pin for IO5\n");
+
+	ret = pwm_pin_set_cycles(pwm0, 7, 0, 200);	// start pwm 7 with a small duty cycle
+	if(ret<0)
+		printk("error pwm_pin_set_cycles on PWM7\n");
+
+	ret = pwm_pin_set_cycles(pwm0, 3, 0, 200);
+	if(ret<0)
+		printk("error pwm_pin_set_cycles on PWM3\n");
+
+	struct gpio_dw_runtime *context = gpiob->driver_data;
+	u32_t base_addr = context->base_addr;
+	
+	iter=0;
+	flag=0;
+
+	total_iter=0;
+
+	while (total_iter<40) {
+		u32_t val = 0;
+
+		gpio_pin_write(gpiob, 2, (iter & BIT(0)));
+		gpio_pin_write(gpiob, 4, (iter & BIT(1)) >> 1);
+		gpio_pin_write(gpiob, 5, (iter & BIT(2))>> 2);
+		
+		gpio_pin_read(gpiob, 6, &val);
+
+		ret = gpio_port_read(gpiob, &gpio_d);
+		
+		printk("iter and gpio_0  %x  %x, %x, %x\n", iter, val, base_addr, gpio_d);
+
+		total_iter++; 
+		iter++;
+		if (iter ==8) 	{
+			iter=0;
+			if (!flag) { 
+				ret = pwm_pin_set_cycles(pwm0, 3, 0, 3000); // switch to a large duty cycle
+				ret = pwm_pin_set_cycles(pwm0, 7, 0, 3000);
+				flag=1;}
+			else { 
+				ret = pwm_pin_set_cycles(pwm0, 3, 0, 200); 	// switch to a small duty cycle
+				ret = pwm_pin_set_cycles(pwm0, 7, 100, 0);		// turn off pwm 7
+				flag=0;}	
+		}
+		k_sleep(SLEEP_TIME);
+	}
+}
diff -urN '--exclude=build' '--exclude=.git' '-x*.pyc' /home/arjun/Downloads/Zephyr_topatch/zephyr/samples/gpio_led_int/CMakeLists.txt /home/arjun/Rtes/zephyrproject/zephyr/samples/gpio_led_int/CMakeLists.txt
--- /home/arjun/Downloads/Zephyr_topatch/zephyr/samples/gpio_led_int/CMakeLists.txt	1969-12-31 17:00:00.000000000 -0700
+++ /home/arjun/Rtes/zephyrproject/zephyr/samples/gpio_led_int/CMakeLists.txt	2019-05-24 11:34:58.000000000 -0700
@@ -0,0 +1,9 @@
+
+# SPDX-License-Identifier: Apache-2.0
+
+cmake_minimum_required(VERSION 3.13.1)
+include($ENV{ZEPHYR_BASE}/cmake/app/boilerplate.cmake NO_POLICY_SCOPE)
+project(gpio_led)
+
+FILE(GLOB app_sources src/*.c)
+target_sources(app PRIVATE ${app_sources})
diff -urN '--exclude=build' '--exclude=.git' '-x*.pyc' /home/arjun/Downloads/Zephyr_topatch/zephyr/samples/gpio_led_int/prj.conf /home/arjun/Rtes/zephyrproject/zephyr/samples/gpio_led_int/prj.conf
--- /home/arjun/Downloads/Zephyr_topatch/zephyr/samples/gpio_led_int/prj.conf	1969-12-31 17:00:00.000000000 -0700
+++ /home/arjun/Rtes/zephyrproject/zephyr/samples/gpio_led_int/prj.conf	2019-06-03 14:02:42.727743000 -0700
@@ -0,0 +1,8 @@
+# nothing here
+CONFIG_PRINTK=y
+CONFIG_SHELL=y
+#CONFIG_KERNEL_SHELL=y
+CONFIG_OBJECT_TRACING=y
+CONFIG_THREAD_MONITOR=y
+CONFIG_INIT_STACKS=y
+CONFIG_PCI_ENUMERATION=y
diff -urN '--exclude=build' '--exclude=.git' '-x*.pyc' /home/arjun/Downloads/Zephyr_topatch/zephyr/samples/gpio_led_int/README.rst /home/arjun/Rtes/zephyrproject/zephyr/samples/gpio_led_int/README.rst
--- /home/arjun/Downloads/Zephyr_topatch/zephyr/samples/gpio_led_int/README.rst	1969-12-31 17:00:00.000000000 -0700
+++ /home/arjun/Rtes/zephyrproject/zephyr/samples/gpio_led_int/README.rst	2019-05-24 11:34:54.000000000 -0700
@@ -0,0 +1,26 @@
+.. _gpio_led:
+
+LED blinking with GPIO signals
+###########
+
+Overview
+********
+A simple example that can be used with galileo board to control a RGB led
+
+Building and Running
+********************
+
+This project outputs 3 gpio signals to light up a RGB led.  It can be built and executed
+on QEMU as follows:
+
+.. zephyr-app-commands::
+   :zephyr-app: samples/gpio_led
+   :board: galileo   
+   :conf: prj.conf
+   :goals: run
+   :compact:
+
+Sample Output
+=============
+
+.. light up a RGB led connected to IO1, IO2, and IO10
diff -urN '--exclude=build' '--exclude=.git' '-x*.pyc' /home/arjun/Downloads/Zephyr_topatch/zephyr/samples/gpio_led_int/sample.yaml /home/arjun/Rtes/zephyrproject/zephyr/samples/gpio_led_int/sample.yaml
--- /home/arjun/Downloads/Zephyr_topatch/zephyr/samples/gpio_led_int/sample.yaml	1969-12-31 17:00:00.000000000 -0700
+++ /home/arjun/Rtes/zephyrproject/zephyr/samples/gpio_led_int/sample.yaml	2019-05-24 11:36:06.000000000 -0700
@@ -0,0 +1,15 @@
+sample:
+  description: gpio_led sample, a simple Zephyr
+    application
+  name: gpio_led
+  platforms: all
+tests:
+  - test:
+      build_only: true
+      filter: CONFIG_UART_CONSOLE and CONFIG_SERIAL_SUPPORT_INTERRUPT
+	  tags: samples tests
+  - singlethread:
+      build_only: true
+      extra_args: CONF_FILE=prj.conf
+      filter: not CONFIG_BT and not CONFIG_GPIO_SCH
+      tags: samples tests
diff -urN '--exclude=build' '--exclude=.git' '-x*.pyc' /home/arjun/Downloads/Zephyr_topatch/zephyr/samples/gpio_led_int/src/main.c /home/arjun/Rtes/zephyrproject/zephyr/samples/gpio_led_int/src/main.c
--- /home/arjun/Downloads/Zephyr_topatch/zephyr/samples/gpio_led_int/src/main.c	1969-12-31 17:00:00.000000000 -0700
+++ /home/arjun/Rtes/zephyrproject/zephyr/samples/gpio_led_int/src/main.c	2019-05-31 12:15:50.000000000 -0700
@@ -0,0 +1,199 @@
+/*
+ * Copyright (c) 2016 Open-RnD Sp. z o.o.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#include <zephyr.h>
+//#include <board.h>
+#include <version.h>
+#include <device.h>
+#include <gpio.h>
+#include <pwm.h>
+#include <misc/util.h>
+#include <misc/printk.h>
+#include <pinmux.h>
+#include "../boards/x86/galileo/board.h"
+#include "../boards/x86/galileo/pinmux_galileo.h"
+#include "../drivers/gpio/gpio_dw_registers.h"
+#include "../drivers/gpio/gpio_dw.h"
+#include <shell/shell.h>
+
+#define EDGE_FALLING    (GPIO_INT_EDGE | GPIO_INT_ACTIVE_LOW)
+#define EDGE_RISING	(GPIO_INT_EDGE | GPIO_INT_ACTIVE_HIGH)
+#define PULL_UP 	0	/* change this to enable pull-up/pull-down */
+#define SLEEP_TIME	1000	/* Sleep time */
+
+int intno;		// numver of interrupts
+
+void interrupt_cb(struct device *gpiob, struct gpio_callback *cb,
+		    u32_t pins)
+{
+	u32_t val;
+
+	gpio_pin_read(gpiob, 6, &val);
+
+/*	if (val==0) {
+		ret=gpio_pin_configure(gpiob, 6,PULL_UP| GPIO_DIR_IN | GPIO_INT | EDGE_RISING);
+	} else {
+		ret=gpio_pin_configure(gpiob, 6,PULL_UP| GPIO_DIR_IN | GPIO_INT | EDGE_FALLING);
+	}
+*/
+	printk("Interrupt arrives at %d %x\n", k_cycle_get_32(), val);
+
+	intno++;
+}
+
+static struct gpio_callback gpio_cb;
+
+// from sample/subsys/shell/shell_module for demo
+
+static int cmd_demo_ping(const struct shell *shell, size_t argc, char **argv)
+{
+	ARG_UNUSED(argc);
+	ARG_UNUSED(argv);
+
+	shell_print(shell, "pong");
+
+	return 0;
+}
+
+static int cmd_demo_params(const struct shell *shell, size_t argc, char **argv)
+{
+	shell_print(shell, "argc = %d", argc);
+	for (size_t cnt = 0; cnt < argc; cnt++) {
+		shell_print(shell, "  argv[%d] = %s", cnt, argv[cnt]);
+	}
+
+	return 0;
+}
+
+static int cmd_version(const struct shell *shell, size_t argc, char **argv)
+{
+	ARG_UNUSED(argc);
+	ARG_UNUSED(argv);
+
+	shell_print(shell, "Zephyr version %s", KERNEL_VERSION_STRING);
+
+	return 0;
+}
+
+SHELL_STATIC_SUBCMD_SET_CREATE(sub_demo,
+	SHELL_CMD(params, NULL, "Print params command.", cmd_demo_params),
+	SHELL_CMD(ping, NULL, "Ping command.", cmd_demo_ping),
+	SHELL_CMD(version, NULL, "Version command.", cmd_version),
+	SHELL_SUBCMD_SET_END /* Array terminated. */
+);
+SHELL_CMD_REGISTER(demo, &sub_demo, "Demo commands", NULL);
+
+
+static struct device *pinmux;  
+
+void main(void)
+{
+	
+	struct device *gpiob, *pwm0;
+	int ret, flag, iter, total_iter;
+
+	u32_t gpio_d;
+	
+	printk("Start running gpio, interrupt, and pwm testing program \n");
+	
+	pinmux=device_get_binding(CONFIG_PINMUX_NAME);
+
+	struct galileo_data *dev = pinmux->driver_data;
+	
+    	gpiob=dev->gpio_dw; 	//retrieving gpio_dw driver struct from pinmux driver
+				// Alternatively, gpiob = device_get_binding(PORT);
+	if (!gpiob) {
+		printk("error\n");
+		return;
+	}
+
+	pwm0 = dev->pwm0;
+	if (!pwm0) {
+		printk("error\n");
+		return;
+	}	
+
+	ret=pinmux_pin_set(pinmux,10,PINMUX_FUNC_A); 	//IO 10
+	if(ret<0)
+		printk("error setting pin for IO10\n");
+	
+	ret=pinmux_pin_set(pinmux,1,PINMUX_FUNC_A); 	//IO1
+	if(ret<0)
+		printk("error setting pin for IO1\n");
+	
+	ret=pinmux_pin_set(pinmux,2,PINMUX_FUNC_A); 	//IO2
+	if(ret<0)
+		printk("error setting pin for IO2\n");
+	
+	ret=pinmux_pin_set(pinmux,3,PINMUX_FUNC_B); 	//IO3 for input interrupt
+	if(ret<0)
+		printk("error setting pin for IO3\n");
+
+	ret=pinmux_pin_set(pinmux,9,PINMUX_FUNC_C); 	//IO9 for pwm 3
+	if(ret<0)
+		printk("error setting pin for IO9\n");
+
+	ret=pinmux_pin_set(pinmux,5,PINMUX_FUNC_C); 	//IO5 for pwm 7
+	if(ret<0)
+		printk("error setting pin for IO5\n");
+
+	ret = pwm_pin_set_cycles(pwm0, 7, 0, 200);	// start pwm 7 with a small duty cycle
+	if(ret<0)
+		printk("error pwm_pin_set_cycles on PWM7\n");
+
+	ret = pwm_pin_set_cycles(pwm0, 3, 0, 200);
+	if(ret<0)
+		printk("error pwm_pin_set_cycles on PWM3\n");
+	
+	ret=gpio_pin_configure(gpiob, 6,
+			   PULL_UP| GPIO_DIR_IN | GPIO_INT | EDGE_RISING); 
+	
+	gpio_init_callback(&gpio_cb, interrupt_cb, BIT(6));
+
+	ret=gpio_add_callback(gpiob, &gpio_cb);
+	if(ret<0)
+		printk("error adding callback\n");
+	
+	ret=gpio_pin_enable_callback(gpiob, 6);
+	if(ret<0)
+		printk("error enabling callback\n");
+	struct gpio_dw_runtime *context = gpiob->driver_data;
+	u32_t base_addr = context->base_addr;
+	
+	iter=0;
+	flag=0;
+
+	total_iter=0;
+
+	while (total_iter<40) {
+		u32_t val = 0;
+
+		gpio_pin_write(gpiob, 2, (iter & BIT(0)));
+		gpio_pin_write(gpiob, 4, (iter & BIT(1)) >> 1);
+		gpio_pin_write(gpiob, 5, (iter & BIT(2))>> 2);
+		
+		gpio_pin_read(gpiob, 6, &val);
+
+		ret = gpio_port_read(gpiob, &gpio_d);
+		
+		printk("iter and gpio_0  %x  %x, %x, %x, %x\n", iter, val, base_addr, gpio_d, intno);
+
+		total_iter++; 
+		iter++;
+		if (iter ==8) 	{
+			iter=0;
+			if (!flag) { 
+				ret = pwm_pin_set_cycles(pwm0, 3, 0, 3000); // switch to a large duty cycle
+				ret = pwm_pin_set_cycles(pwm0, 7, 0, 3000);
+				flag=1;}
+			else { 
+				ret = pwm_pin_set_cycles(pwm0, 3, 0, 200); 	// switch to a small duty cycle
+				ret = pwm_pin_set_cycles(pwm0, 7, 100, 0);		// turn off pwm 7
+				flag=0;}	
+		}
+		k_sleep(SLEEP_TIME);
+	}
+}
diff -urN '--exclude=build' '--exclude=.git' '-x*.pyc' /home/arjun/Downloads/Zephyr_topatch/zephyr/samples/HCSR_app/CMakeLists.txt /home/arjun/Rtes/zephyrproject/zephyr/samples/HCSR_app/CMakeLists.txt
--- /home/arjun/Downloads/Zephyr_topatch/zephyr/samples/HCSR_app/CMakeLists.txt	1969-12-31 17:00:00.000000000 -0700
+++ /home/arjun/Rtes/zephyrproject/zephyr/samples/HCSR_app/CMakeLists.txt	2019-06-20 06:02:06.063699337 -0700
@@ -0,0 +1,8 @@
+# SPDX-License-Identifier: Apache-2.0
+
+cmake_minimum_required(VERSION 3.13.1)
+include($ENV{ZEPHYR_BASE}/cmake/app/boilerplate.cmake NO_POLICY_SCOPE)
+project(NONE)
+
+target_sources(app PRIVATE src/main.c)
+
diff -urN '--exclude=build' '--exclude=.git' '-x*.pyc' /home/arjun/Downloads/Zephyr_topatch/zephyr/samples/HCSR_app/prj.conf /home/arjun/Rtes/zephyrproject/zephyr/samples/HCSR_app/prj.conf
--- /home/arjun/Downloads/Zephyr_topatch/zephyr/samples/HCSR_app/prj.conf	1969-12-31 17:00:00.000000000 -0700
+++ /home/arjun/Rtes/zephyrproject/zephyr/samples/HCSR_app/prj.conf	2019-06-20 06:14:00.756648169 -0700
@@ -0,0 +1,9 @@
+CONFIG_PRINTK=y
+CONFIG_GPIO=y
+CONFIG_SHELL=y
+CONFIG_SENSOR=y
+CONFIG_KERNEL_SHELL=y
+CONFIG_THREAD_MONITOR=y
+CONFIG_INIT_STACKS=y
+CONFIG_HCSR04=y
+CONFIG_DEVICE_SHELL=y
diff -urN '--exclude=build' '--exclude=.git' '-x*.pyc' /home/arjun/Downloads/Zephyr_topatch/zephyr/samples/HCSR_app/src/main.c /home/arjun/Rtes/zephyrproject/zephyr/samples/HCSR_app/src/main.c
--- /home/arjun/Downloads/Zephyr_topatch/zephyr/samples/HCSR_app/src/main.c	1969-12-31 17:00:00.000000000 -0700
+++ /home/arjun/Rtes/zephyrproject/zephyr/samples/HCSR_app/src/main.c	2019-06-26 16:48:24.835534265 -0700
@@ -0,0 +1,160 @@
+#include <zephyr.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <version.h>
+#include <device.h>
+#include <gpio.h>
+#include <pwm.h>
+#include <sensor.h>
+#include <misc/util.h>
+#include <misc/printk.h>
+#include <pinmux.h>
+#include "../boards/x86/galileo/board.h"
+#include "../boards/x86/galileo/pinmux_galileo.h"
+#include "../drivers/gpio/gpio_dw_registers.h"
+#include "../drivers/gpio/gpio_dw.h"
+#include <shell/shell.h>
+
+int ret; //return value check
+struct sensor_value dist_val[256]; //results buffer 
+struct device *hcsr; //device struct to store bound device 
+u32_t stop_time[256] = {0}; //stop time buffer
+u32_t start_time;
+int p = 0;
+
+void hcsr0_func(); //function for HCSR0 selection
+void hcsr1_func(); //function for HCSSR1 selection 
+
+/*Select Shell Command*/
+static int cmd_select(const struct shell *shell, size_t argc, char **argv)
+{
+  
+  int n = 0;
+
+  n = atoi(argv[1]); //sensor
+
+
+  if(n == 1) {
+
+  	hcsr0_func(); //calling HCSR0 if 1
+  	
+   }
+  else if(n == 2){
+
+    hcsr1_func(); //calling HCSR1 if 2
+   
+  }
+  else{
+
+  	printk("No device selected please select a device\n");
+  }
+ return 0;
+}
+
+/*Start Measurement Command*/
+static int cmd_start(const struct shell *shell, size_t argc, char **argv)
+{
+  p=0;
+  p = atoi(argv[1]); //number of samples required
+
+  if(p==0){
+  	printk("Please select some number of samples\n");
+  	return 0;
+  }
+
+  for(int i=0;i<256;i++){ // setting buffers to zero
+  	dist_val[i].val1 = 0;
+  	stop_time[i] = 0;
+  }
+  
+  start_time = k_uptime_get_32(); //time at start of measurement 
+  for(int i=0;i<p;i++){
+        ret = sensor_sample_fetch(hcsr); //fetching samples
+        if(ret<0){
+             printk("Error: sensor_sample_fetch\n");
+             return 0;
+        }
+        ret = sensor_channel_get(hcsr,SENSOR_CHAN_ALL,&dist_val[i]); //storing samples
+        if(ret<0){
+             printk("Error: Sensor timed out\n");
+             return 0;
+        }
+        stop_time[i] = k_uptime_get_32(); //times when measurement was taken
+        k_sleep(450);
+      }
+
+return 0;
+}
+
+/*Dump Shell Command*/
+static int cmd_dump(const struct shell *shell, size_t argc, char **argv)
+{
+  int p1,p2 = 0;
+
+  p1 = atoi(argv[1]); //sample range from p1 to p2
+  p2 = atoi(argv[2]); 
+
+  if(p1 == 0 || p1>p || p2>p)
+  {
+    printk("Error: Please select valid value\n");
+    return 0;
+  }
+  
+  if(p2 == 0)
+  { 
+    printk("Sample number: %d Elapsed time: %u ms Distance Value: %d cm\n", p1,(stop_time[p1-1]-start_time), dist_val[p1-1].val1); 
+  }
+  else{
+
+   if(p1>p2){
+    printk("Error: cannot print values p1 is larger than p2\n");
+    return 0;
+  }
+
+   printk("Printing results ranging from %d to %d\n", p1, p2);
+
+   for(int i = p1-1; i<=p2-1; i++) 
+   {
+     printk("Sample number: %d Elapsed time: %u ms Distance Value: %d cm\n", i+1,(stop_time[i]-start_time), dist_val[i].val1);
+   }
+ }
+ return 0;
+}
+
+/*To select HCSR0*/
+void hcsr0_func()
+{
+	hcsr = device_get_binding("HCSR04_0"); //device binding 
+    if(hcsr == NULL) {
+          printk("Could not find device HCRSR0\n");
+          return;
+     }
+    printk("Sensor selected: %s\n", hcsr->config->name);
+}
+
+/*To select HCSR1*/
+void hcsr1_func()
+{
+   hcsr = device_get_binding("HCSR04_1"); //device binding 
+    if(hcsr == NULL) {
+          printk("Could not find device HCSR1\n");
+          return;
+     }
+    printk("Sensor selected: %s\n", hcsr->config->name);
+}
+
+/*Shell Commands*/
+SHELL_CMD_ARG_REGISTER(Select_HCSR,NULL,"To select the sensor: Select_HCSR n (n=0, 1 or 2, to enable none, HCSR0, or HCSR1)",cmd_select, 2, 1);
+SHELL_CMD_ARG_REGISTER(Start_HCSR,NULL,"To start sensing for p nunber of distance measures from selected HCSR sensor: Start_HCSR p where p <= 256",cmd_start, 2, 1);
+SHELL_CMD_ARG_REGISTER(Dump_HCSR,NULL,"To print out the distance measure in centimeters and timestamps recorded in previous measurment on console: Dump_HCSR p1 p2 where p1 <= p2",cmd_dump, 2, 1);
+
+void main()
+{
+  printk("HCSR_APP\n");
+  printk("Command to select the sensor: Select_HCSR 'n' where n=0, 1 or 2, to enable none, HCSR0, or HCSR1\n");
+  printk("Command to start sensing for p nunber of distance measures from selected HCSR sensor: Start_HCSR 'p' where p <= 256 and p!=0\n");
+  printk("Command to print out the distance measure in centimeters and timestamps recorded in previous measurment on console: Dump_HCSR 'p1' 'p2' where p1 <= p2 and p1!=0.\n A single sample can also be dumped\n");
+  printk("Press enter to begin\n");
+
+}
+
diff -urN '--exclude=build' '--exclude=.git' '-x*.pyc' /home/arjun/Downloads/Zephyr_topatch/zephyr/samples/measure_43/CMakeLists.txt /home/arjun/Rtes/zephyrproject/zephyr/samples/measure_43/CMakeLists.txt
--- /home/arjun/Downloads/Zephyr_topatch/zephyr/samples/measure_43/CMakeLists.txt	1969-12-31 17:00:00.000000000 -0700
+++ /home/arjun/Rtes/zephyrproject/zephyr/samples/measure_43/CMakeLists.txt	2019-05-27 21:43:47.440651000 -0700
@@ -0,0 +1,8 @@
+# SPDX-License-Identifier: Apache-2.0
+
+cmake_minimum_required(VERSION 3.13.1)
+include($ENV{ZEPHYR_BASE}/cmake/app/boilerplate.cmake NO_POLICY_SCOPE)
+project(shell)
+
+target_sources(app PRIVATE src/main.c)
+
diff -urN '--exclude=build' '--exclude=.git' '-x*.pyc' /home/arjun/Downloads/Zephyr_topatch/zephyr/samples/measure_43/prj.conf /home/arjun/Rtes/zephyrproject/zephyr/samples/measure_43/prj.conf
--- /home/arjun/Downloads/Zephyr_topatch/zephyr/samples/measure_43/prj.conf	1969-12-31 17:00:00.000000000 -0700
+++ /home/arjun/Rtes/zephyrproject/zephyr/samples/measure_43/prj.conf	2019-05-21 23:36:36.301278000 -0700
@@ -0,0 +1,9 @@
+CONFIG_PRINTK=y
+CONFIG_SHELL=y
+CONFIG_LOG=y
+CONFIG_KERNEL_SHELL=y
+CONFIG_THREAD_MONITOR=y
+CONFIG_INIT_STACKS=y
+CONFIG_BOOT_BANNER=n
+CONFIG_THREAD_NAME=y
+CONFIG_DEVICE_SHELL=y
diff -urN '--exclude=build' '--exclude=.git' '-x*.pyc' /home/arjun/Downloads/Zephyr_topatch/zephyr/samples/measure_43/src/main.c /home/arjun/Rtes/zephyrproject/zephyr/samples/measure_43/src/main.c
--- /home/arjun/Downloads/Zephyr_topatch/zephyr/samples/measure_43/src/main.c	1969-12-31 17:00:00.000000000 -0700
+++ /home/arjun/Rtes/zephyrproject/zephyr/samples/measure_43/src/main.c	2019-06-05 21:40:26.070978443 -0700
@@ -0,0 +1,496 @@
+#include <zephyr.h>
+//#include <board.h>
+#include <version.h>
+#include <device.h>
+#include <gpio.h>
+#include <pwm.h>
+#include <misc/util.h>
+#include <misc/printk.h>
+#include <pinmux.h>
+#include "../boards/x86/galileo/board.h"
+#include "../boards/x86/galileo/pinmux_galileo.h"
+#include "../drivers/gpio/gpio_dw_registers.h"
+#include "../drivers/gpio/gpio_dw.h"
+#include <shell/shell.h>
+
+#define EDGE_RISING	(GPIO_INT_EDGE | GPIO_INT_ACTIVE_HIGH)
+#define PULL_UP 	0	/* change this to enable pull-up/pull-down */
+
+/* size of stack area used by each thread */
+#define STACKSIZE 1024
+
+/* scheduling priority of threads */
+#define PRIORITY_A 5
+
+#define PRIORITY 7
+
+#define PRIORITY_B 10
+
+/* sleep in ms */
+#define SLEEPTIME 1000
+
+K_SEM_DEFINE(threadA_sem, 0, 1); /* starts off "not available" */
+K_SEM_DEFINE(threadB_sem, 1, 1); /* starts off "available" */
+K_MUTEX_DEFINE(my_mutex);/* mutex for message passing */
+
+/* Thread initialization */
+K_THREAD_STACK_DEFINE(threadB_stack_area,STACKSIZE);
+K_THREAD_STACK_DEFINE(threadA_stack_area,STACKSIZE);
+K_THREAD_STACK_DEFINE(tx_thread_stack_area,STACKSIZE);
+K_THREAD_STACK_DEFINE(rx_thread_stack_area,STACKSIZE);
+static struct k_thread threadA_data;
+static struct k_thread threadB_data;
+static struct k_thread tx_thread_data;
+static struct k_thread rx_thread_data;
+
+/* GPIO and PWM initialization */
+static struct device *pinmux;
+static struct gpio_callback gpio_cb;
+static struct gpio_callback gpio_cb_1;
+struct device *gpiob, *pwm0;
+int ret,msg,start_time,stop_time;
+int give_A,take_A,give_B;
+
+static int count = 0; /* sample count */
+int measure1_buff[100] = {0}; /* buffer for measurement 1 */
+int measure2_buff[101] = {0}; /* buffer for measurement 2 */
+int measure3_buff[100] = {0}; /* buffer for measurement 3 */ 
+
+struct data_item_type {
+      u32_t field1;
+      u32_t field2;
+      u32_t field3;
+};
+
+k_tid_t tid_a; /* thread A id */
+k_tid_t tid_b; /* thread B id */
+   
+char __aligned(4) my_msgq_buffer[12 * sizeof(struct data_item_type)];
+struct k_msgq my_msgq;
+
+void interrupt_cb(struct device *gpiob, struct gpio_callback *cb, u32_t pins) /* interrupt callback for IO3 */
+{
+  //take time stamp
+  stop_time = SYS_CLOCK_HW_CYCLES_TO_NS(k_cycle_get_32());
+  measure1_buff[count] = (stop_time - start_time);
+  //printk("Interrupt arrived %d\n", count+1);
+  ++count;
+}
+
+void interrupt_cb_1(struct device *gpiob, struct gpio_callback *cb, u32_t pins) /* interrupt callback for IO2 */
+{
+  //take time stamp
+  stop_time = SYS_CLOCK_HW_CYCLES_TO_NS(k_cycle_get_32());
+  measure2_buff[count] = stop_time;
+  //printk("Interrupt arrived at two %d\n", count+1);
+  ++count;
+}
+
+/* lower priority thread for context switch */
+void threadB( void *dummy1, void *dummy2, void *dummy3)
+{
+  ARG_UNUSED(dummy1);
+  ARG_UNUSED(dummy2);
+  ARG_UNUSED(dummy3);
+  
+  while(count<100)
+  {
+    k_sleep(20);
+    k_sem_take(&threadB_sem, K_FOREVER); 
+
+    /* say hello */
+    //printk("Hi from thread B\n");
+ 
+    give_A = SYS_CLOCK_HW_CYCLES_TO_NS(k_cycle_get_32());
+    k_sem_give(&threadA_sem);
+  }
+return;
+}
+
+/*higher priority thread for context switch */
+void threadA( void *dummy1, void *dummy2, void *dummy3)
+{
+  ARG_UNUSED(dummy1);
+  ARG_UNUSED(dummy2);
+  ARG_UNUSED(dummy3);
+
+  /*create thread B */
+  tid_b = k_thread_create(&threadB_data,threadB_stack_area,STACKSIZE, threadB, NULL, NULL, NULL, PRIORITY_B, 0, K_NO_WAIT);      
+  k_thread_name_set(tid_b, "thread_b");
+
+  while(count < 100)
+  {
+    k_sem_take(&threadA_sem, K_FOREVER);
+    take_A = SYS_CLOCK_HW_CYCLES_TO_NS(k_cycle_get_32());
+
+    /* say hello */
+    //printk("Hi from thread A\n");
+    
+    //give_B1 = SYS_CLOCK_HW_CYCLES_TO_NS(k_cycle_get_32());
+    k_sem_give(&threadB_sem);
+    give_B = SYS_CLOCK_HW_CYCLES_TO_NS(k_cycle_get_32());
+
+    int val = (take_A - give_A) - (give_B - take_A);
+    measure3_buff[count] = val;
+    ++count;
+  }
+return;
+}
+/* producer thread for message passing */
+void tx_thread( void *dummy1, void *dummy2, void *dummy3)
+{
+  ARG_UNUSED(dummy1);
+  ARG_UNUSED(dummy2);
+  ARG_UNUSED(dummy3);
+
+  printk("Background thread started\n");
+
+  struct data_item_type data;
+
+  while(count < 101)
+  {
+    if (k_mutex_lock(&my_mutex, K_FOREVER) != 0){ //mutex lock
+         printk("Mutex not locked\n");
+    } 
+    
+    data.field1 = ++msg; // set data value
+   
+    while (k_msgq_put(&my_msgq, &data, K_NO_WAIT) != 0) { // send data
+            /* message queue is full: purge old data & try again */
+            k_msgq_purge(&my_msgq);
+        }
+
+    //printk("Posted message %d\n", msg);
+
+
+    k_sleep(5); //give the receiver thread a chance to start
+
+     /* unlock mutex */
+    k_mutex_unlock(&my_mutex);
+  }
+ return;     
+}
+
+/* receiver thread for message passing */
+void rx_thread( void *dummy1, void *dummy2, void *dummy3)
+{
+  ARG_UNUSED(dummy1);
+  ARG_UNUSED(dummy2);
+  ARG_UNUSED(dummy3);
+
+  struct data_item_type data;
+
+  while(count < 101)
+  {
+    if (k_mutex_lock(&my_mutex, K_FOREVER) != 0){ //lock mutex
+         printk("Mutex not locked\n");
+    } else {
+        k_msgq_get(&my_msgq, &data, K_FOREVER); //receive message
+        //printk("Message received %d\n", data.field1);
+    }
+
+    k_sleep(5);
+
+     /* unlock mutex */
+    k_mutex_unlock(&my_mutex);
+  }
+ return;
+}
+
+/* to initialize interrupt and gpio pins */
+void gpio_init()
+{
+
+  pinmux = device_get_binding(CONFIG_PINMUX_NAME);
+
+  struct galileo_data *dev = pinmux->driver_data;
+
+  gpiob=dev->gpio_dw;
+  if(!gpiob){ 
+        printk("error\n");
+        return;
+   }
+
+   pwm0= dev->pwm0;
+
+  if(!pwm0){
+       printk("error\n");
+    }
+
+    ret=pinmux_pin_set(pinmux,1,PINMUX_FUNC_A); // IO1 for red led 
+  if(ret<0)
+      printk("error setting the pin for IO1\n");
+
+      ret=pinmux_pin_set(pinmux,12,PINMUX_FUNC_A); // IO12 for green led  
+  if(ret<0)
+      printk("error setting the pin for IO12\n");
+
+  ret=pinmux_pin_set(pinmux,3,PINMUX_FUNC_B); // IO3 for input interrupt 
+  if(ret<0)
+      printk("error setting the pin for IO3\n");
+
+  ret=pinmux_pin_set(pinmux,10,PINMUX_FUNC_A); // IO10 for triggering interrupt 
+  if(ret<0)
+      printk("error setting the pin for IO10\n");
+
+    ret=pinmux_pin_set(pinmux,2,PINMUX_FUNC_B); // IO2 for input interrupt 
+  if(ret<0)
+      printk("error setting the pin for IO2\n");
+
+  ret=pinmux_pin_set(pinmux,9,PINMUX_FUNC_C); // IO9 for PWM7
+  if(ret<0)
+      printk("error setting the pin for IO9\n");
+
+  ret=gpio_pin_configure(gpiob,6,PULL_UP | GPIO_DIR_IN | GPIO_INT | EDGE_RISING); //configure IO3 for interrupt
+
+  ret=gpio_pin_configure(gpiob,5,PULL_UP | GPIO_DIR_IN | GPIO_INT | EDGE_RISING); //configure IO2 for interrupt
+}
+
+static int cmd_gpio_int(const struct shell *shell, size_t argc, char **argv)
+{
+  ARG_UNUSED(argc);
+  ARG_UNUSED(argv);
+  gpio_pin_write(gpiob, 7, 0);  /* turn green off */
+  gpio_pin_write(gpiob, 4, 1);  /* turn red on */
+  printk("Running measurement 1: Interrupt latency without background task\n");
+  count = 0;
+  
+  //gpio_init();
+
+  /* configuring interrupt on IO3 */
+  gpio_init_callback(&gpio_cb, interrupt_cb, BIT(6));
+
+  ret = gpio_add_callback(gpiob, &gpio_cb);   
+  if(ret<0)
+      printk("error adding callback\n");
+
+  ret=gpio_pin_enable_callback(gpiob,6);
+  if(ret<0) 
+      printk("error enabling callback\n");
+
+  while(count<100){
+       gpio_pin_write(gpiob, 2, 0); /* triggering interrupt */
+       k_sleep(10);
+       start_time = SYS_CLOCK_HW_CYCLES_TO_NS(k_cycle_get_32());
+       gpio_pin_write(gpiob, 2, 1);
+         
+       k_sleep(20);
+  }
+
+  gpio_pin_write(gpiob, 2, 0);  /* IO 10 off */
+  int avg = 0;
+  for(int i = 0; i<100; i++) 
+  { 
+    avg = avg + measure1_buff[i];
+  }
+
+  avg = avg/100;
+ 
+  for(int i = 0; i < 100; i++)
+  {
+    printk("Interrupt latency with no background task sample %d : %d ns\n", i+1, measure1_buff[i]); 
+  } 
+
+  printk("Average Interrupt latency with no background task: %d ns\n", avg);
+  gpio_pin_write(gpiob, 4, 0);  /* turn red off */
+  gpio_pin_write(gpiob, 7, 1);  /* turn green on */
+  
+  printk("Finished Measurement 1.\n"); 
+  return 0;
+} 
+
+static int cmd_gpio_int_back(const struct shell *shell, size_t argc, char **argv)
+{
+  ARG_UNUSED(argc);
+  ARG_UNUSED(argv);
+  gpio_pin_write(gpiob, 7, 0);  /* turn green off */
+  gpio_pin_write(gpiob, 4, 1);  /* turn red on */
+  printk("Running measurement 2: Interrupt latency with background task\n");
+  count = 0;
+  //gpio_init();
+
+  /* starting measurement 1 */
+
+  /* configure interrupt at IO3 */
+  gpio_init_callback(&gpio_cb, interrupt_cb, BIT(6));
+
+  ret = gpio_add_callback(gpiob, &gpio_cb);   
+  if(ret<0)
+      printk("error adding callback\n");
+
+  ret=gpio_pin_enable_callback(gpiob,6);
+  if(ret<0) 
+      printk("error enabling callback\n");
+
+  while(count<100){
+       gpio_pin_write(gpiob, 2, 0); //trigger IO10 interrupt.
+       k_sleep(10);
+       start_time = SYS_CLOCK_HW_CYCLES_TO_NS(k_cycle_get_32());
+       gpio_pin_write(gpiob, 2, 1); 
+         
+       k_sleep(20);
+  }
+
+  count = 0;
+  gpio_pin_write(gpiob, 2, 0);
+  printk("Finished Measurement 1.\n");
+
+  /* starting measurement 2 */
+
+  /* configuring interrupt at IO2 */ 
+  gpio_init_callback(&gpio_cb_1, interrupt_cb_1, BIT(5));
+
+  ret = gpio_add_callback(gpiob, &gpio_cb_1);   
+  if(ret<0)
+      printk("error adding callback\n");
+
+  ret=gpio_pin_enable_callback(gpiob,5);
+  if(ret<0) 
+      printk("error enabling callback\n");
+  
+  /* initialize msg q */
+  k_msgq_init(&my_msgq, my_msgq_buffer, sizeof(struct data_item_type), 12);
+
+  /* start the sender thread X */
+  k_tid_t tid_tx = k_thread_create(&tx_thread_data, tx_thread_stack_area, STACKSIZE, tx_thread, NULL, NULL, NULL, PRIORITY, 0, K_NO_WAIT);
+  k_thread_name_set(tid_tx, "rx_thread");
+
+  /* start the receiver thread Y */
+  k_tid_t tid_rx = k_thread_create(&rx_thread_data, rx_thread_stack_area, STACKSIZE, rx_thread, NULL, NULL, NULL, PRIORITY, 0, K_NO_WAIT);
+  k_thread_name_set(tid_rx, "tx_thread");
+
+  /* start the pwm */
+    ret = pwm_pin_set_cycles(pwm0, 7, 0, 1639); /* triggering interrupt using PWM */
+  if(ret<0)
+      printk("error pwm_pin_set_cycles on PWM7\n");
+
+  while(count < 101) // turn pwm off when done collecting 100 samples.
+  {
+   printk("");
+  }
+
+  /* stop the pwm */
+  ret = pwm_pin_set_cycles(pwm0, 7, 100, 0);
+  if(ret<0)
+     printk("error pwm_pin_set_cycles on PWM7\n");
+  
+  /* calculating final values */
+  int max1=0,max2 = 0;
+  int min1=100000000,min2 = 100000000;
+
+  for(int i = 0; i<100; i++)
+  {
+    measure2_buff[i] = measure2_buff[i+1] - measure2_buff[i];  // calculating delta from measurement 2
+  }
+  
+  for(int i = 0; i < 100 ; i++) // max of measurement 1
+  {
+    if(measure1_buff[i] > max1)
+      {
+        max1 = measure1_buff[i];
+      }
+  }
+
+    for(int i = 0; i < 100 ; i++) // min of measurement 1
+  {
+    if(measure1_buff[i] < min1)
+      {
+        min1 = measure1_buff[i];
+      }
+  }
+
+    for(int i = 0; i < 100 ; i++) // max of delta values from measurement 2
+  {
+    if(measure2_buff[i] > max2)
+      {
+        max2 = measure2_buff[i];
+      }
+  }
+
+    for(int i = 0; i < 100 ; i++) // min of delta values from measurement 2
+  {
+    if(measure2_buff[i] < min2)
+      {
+        min2 = measure2_buff[i];
+      }
+  }
+
+  int avg = 0; //taking average of all delta values 
+  for(int i = 0; i<100; i++) 
+  { 
+    avg = avg + measure2_buff[i];
+  }
+
+  avg = avg/100;
+    
+  int max_final = (max2 - min2 + 2*(max1-min1))/2; //final value calculations 
+  
+
+  for(int i = 0; i<100; i++) //printing values 
+  {
+    printk("Delta sample %d: %d ns\n", i+1, measure2_buff[i]); 
+  }
+
+  printk("Average delta value is: %d ns\n", avg);
+  printk("The Interrupt latency with a background task is: %d ns\n", max_final);
+  gpio_pin_write(gpiob, 4, 0);  /* turn red off */
+  gpio_pin_write(gpiob, 7, 1);  /* turn green on */
+  printk("Finished Measurement 2.\n");
+  
+  return 0;
+}
+
+static int cmd_context_thread(const struct shell *shell, size_t argc, char **argv)
+{ 
+  ARG_UNUSED(argc);
+  ARG_UNUSED(argv);
+  gpio_pin_write(gpiob, 7, 0);  /* turn green off */
+  gpio_pin_write(gpiob, 4, 1);  /* turn red on */
+  printk("Running Measurement 3: Context switch latency\n");
+  count = 0;
+
+  /* create thread A with higher priority */
+
+  tid_a = k_thread_create(&threadA_data,threadA_stack_area,STACKSIZE, threadA, NULL, NULL, NULL, PRIORITY_A, 0, K_NO_WAIT);
+  k_thread_name_set(tid_a, "thread_a");
+
+  while(count < 100)
+  {
+    printk("");
+  }
+
+  int avg = 0; // taking average
+  for(int i = 0; i<100; i++) 
+  { 
+    avg = avg + measure3_buff[i];
+  }
+
+  avg = avg/100;
+
+   
+   for( int i=0; i<100; i++) //printing values 
+   {
+      printk(" The context switch latency %d : %d ns\n", i, measure3_buff[i]);
+   }
+   printk("Average context switch latency is %d ns\n",avg);
+   gpio_pin_write(gpiob, 4, 0);  /* turn red off */
+   gpio_pin_write(gpiob, 7, 1);  /* turn green on */ 
+   printk("Finished Measurement 3.\n");     
+  return 0;
+}
+
+SHELL_STATIC_SUBCMD_SET_CREATE(sub_measure, 
+SHELL_CMD(1, NULL, "Interrupt latency measurement w/o background process.", cmd_gpio_int),
+SHELL_CMD(2, NULL, "Interrupt latency measurement w/background process.", cmd_gpio_int_back), 
+SHELL_CMD(3, NULL, "Context switch latency measurement.", cmd_context_thread),SHELL_SUBCMD_SET_END);
+
+
+SHELL_CMD_REGISTER(measure,&sub_measure,"Measure commands",NULL);
+
+
+void main(void)
+{
+  printk("Hi! PLease type ""measure"" and press Enter"); 
+  gpio_init();
+  gpio_pin_write(gpiob, 7, 1); //turn green on
+}
